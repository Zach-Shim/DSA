## **Technical Questions**

Technical questions form the basis for how many of the top tech company’s interview.
Many candidates are intimidated by the difficulty of these questions, but there are logical ways to approach them.
## **What You Need to Know**

Most interviews are not knowledge tests.

The sorts of data structure and algorithm questions that many companies focus on are not based on specific algorithms (i.e., balance a binary tree) or other complex algorithms.

However, they do assume a **baseline of knowledge**.
##### **Core Data Structures, Algorithms, and Concepts**

You're usually only expected to know the basics.
Here's a few tables of the absolute, must-have knowledge:

| Data Structures | |
|---|---|
| Arrays ||
| Vectors / ArrayLists ||
| Stack & Queues ||
|Linked lists||
|Trees & Tries||
|Heaps||
|Graphs||
|Hash Tables||

|Algorithms| |
|---|---|
|Merge Sort||
|Quick Sort||
|Binary Search||
|Depth-First Search||
|Breadth-First Search||

|Concepts| |
| --- | --- |
|Array Rotation||
|Matrix||
|Bit Manipulation||
|Recursion||
|Backtracking||
|Dynamic Programming||
|Memory (Stack vs. Heap)||
|Big O Time and Space||

For each of these topics, make sure you understand
1. how to use them
2. how to implement them
3. space and time complexity
## **How to Prepare**

Many candidates just read through problems and solutions.
That's like trying to learn calculus by reading a problem and its answer.

**You need to practice solving problems**.

Doing so will allow you **identify common patterns and practice problem solving**.

**Memorizing solutions won't help you much**.

For each problem in this book (and any other problem you might encounter), do the following:

1. **Try to solve the problem on your own.**
	1. Hints are provided at the back of this book but push yourself to develop a solution with as little help as possible. Many questions are designed to be tough-that's okay!
	2. When you're solving a problem, make sure to think about
                                                  i.      space complexity
                                                                 and
                                                 ii.      time complexity
	3. Solving a problem on your own forces you to critically think. This sets the stage for real-world interviews where you can’t look up an answer at the back of a book.

2. **Write the code on paper.**
	1. Coding on a computer offers luxuries such as syntax highlighting, code completion, and quick debugging. Coding on paper does not.
	2. Get used to this-and to how slow it is to write and edit code-by coding on paper.

3. **Test your code-on paper.**
	1. This means testing the general cases, base cases, error cases, and so on.
	2. You'll need to do this during your interview, so it's best to practice this in advance.

4. **Type your paper code as-is into a computer.**
	1. You will probably make a bunch of mistakes.
	2. Start a list of all the errors you make so that you can keep these in mind during the actual interview.

5. **Do as many mock interviews as possible.** 
	1. You and a friend can take turns giving each other mock interviews. Though your friend may not be an expert interviewer, he or she may still be able to walk you through a coding or algorithm problem.
	2. You'll also learn a lot by experiencing what it's like to be an interviewer.

## **What To Expect**

**Interviews are supposed to be difficult.**

If you don't get every, or even any, answer immediately, that's okay! That's the normal experience, and **it's not bad**.

**Listen for guidance from the interviewer.**

The interviewer might take a more active or less active role in your problem solving. The level of interviewer participation depends on
- your performance,
- the difficulty of the question,
- what the interviewer is looking for,
    and
- the interviewer's own personality.